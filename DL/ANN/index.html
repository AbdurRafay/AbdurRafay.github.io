  <html>
  <head>
    <style type="text/css">
    canvas {
          /*width: 100%;
          height: 97%;
          */background: pink;
        }
      </style>
      <script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/5.1.2/math.min.js"></script>
      <script>
        data = {
          x: [ [1,2,3],  [4,5,6] ],
          y: [ [1,0,1] ] 
        }
        X = math.matrix(data.x);
        X = math.transpose( X.resize([X.size()[0]+1,X.size()[1]], 1) );
        Y = math.transpose( math.matrix(data.y) );
        numOfLayers = 1 + 1 + 1;
        lengthOfHiddenLayer = 2;
        W = []        
        initWeights()
        A = []
        calculateActivations()
        width = window.outerWidth * 0.67;
        height = window.outerHeight * 0.77;
        // stage;
        neurons = [];
        neuronRadius = 50;
        duration = 5000;
        function init() {
          var canvas = document.getElementById("demoCanvas");
          canvas.width = width;
          canvas.height = height;
          stage = new createjs.Stage("demoCanvas");

          var xSpace = width/(numOfLayers);
          
          for (var i = 0; i < numOfLayers; i++) {
            if (i == 0) {
              numOfNeurons = X.size()[1];
            }
            else if (i == numOfLayers-1) {
              numOfNeurons = Y.size()[1];
            } 
            else {
              numOfNeurons = lengthOfHiddenLayer;
            }
            neurons.push([]);
            for (var j = 0; j < numOfNeurons; j++) {
              neurons[i].push(addNeuron(i*xSpace + xSpace/2, j*height/numOfNeurons + height/numOfNeurons/2, neuronRadius));
              // console.log(i,j);
              if (i == 0) { 
                var connection = connectNeurons(getLocation(neurons[i][j], -neuronRadius*2, 0), neurons[i][j]);
                continue;
              }
              for(neuron in neurons[i-1]) {
                var connection = connectNeurons(neurons[i-1][neuron], neurons[i][j]);
              }
              if (i == numOfLayers-1) { 
                var connection = connectNeurons(neurons[i][j], getLocation(neurons[i][j], neuronRadius*2, 0));
              }            
            }
          }

          X._data.forEach(function (sample, sampleIndex) {
            if (sampleIndex == 0) {
              simulateForwardPass(sample, sampleIndex)
            } 
          })


        }
        function simulateForwardPass(sample, sampleIndex) {
          // input layer
          neurons[0].forEach(function (neuron, neuronIndex) {
            var dummyNeuron = getLocation(neuron, -neuronRadius*2, 0)
            var input = A[0]._data[sampleIndex][neuronIndex]
            var labels = labelConnection(dummyNeuron, neuron, input, "")
            simulateLabels(labels.inputText, labels.weightText, dummyNeuron, neuron)
          })
          
          // hidden layers
          neurons.forEach(function (layer, layerIndex) {
            var toLayer = neurons[layerIndex+1]
            if (toLayer) {
              layer.forEach(function (neuron, neuronIndex) {
                toLayer.forEach(function (toNeuron, toNeuronIndex) {
                  sleep((layerIndex+1) * duration).then(() => {
                    console.log(neuronIndex,toNeuronIndex)
                    var input = A[layerIndex]._data[sampleIndex][neuronIndex]
                    var weight = W[layerIndex]._data[neuronIndex][toNeuronIndex]
                    var labels = labelConnection(neuron, toNeuron, input, weight);
                    simulateLabels(labels.inputText, labels.weightText, neuron, toNeuron, true);
                  })
                  sleep((layerIndex+2) * duration).then(() => {
                    var input = A[layerIndex+1]._data[sampleIndex][toNeuronIndex]
                    var labels = labelConnection(toNeuron, null, round(input), "");
                  })                        
                })
              })  
            }                              
          })

          // output layer
          neurons[neurons.length-1].forEach(function (neuron, neuronIndex) {
            sleep((numOfLayers) * duration).then(() => {
              var dummyNeuron = getLocation(neuron, neuronRadius*2, 0)
              var input = A[neurons.length-1]._data[sampleIndex][neuronIndex]
              var labels = labelConnection(neuron, dummyNeuron, input, "")
              simulateLabels(labels.inputText, labels.weightText, neuron, dummyNeuron)
            })
          })

        }
        function calculateActivations() {
          for (var i = 0; i < numOfLayers; i++) {
            var a
            if (i==0) {
              a = X
              // w = math.matrix([ [1,2],  [3,4], [5,6] ])
            } else {
              var z = math.multiply(A[i-1],W[i-1])
              a = sigmoid(z)
            }
            A.push(a)
          }
          // var A1 = math.matrix([ [100,200], [300,400], [500,600] ])
          // var A2 = math.matrix([ [111], [222], [333] ])
          // A = [math.transpose(X), A1, A2]
        }
        function sigmoid(z) {
          var bottom = math.add(1, math.exp(math.multiply(-1, z)));
          var a = math.dotDivide(1, bottom)
          return a
        }
        function round(num) {
          return Math.round(num * 100) / 100
        }
        function initWeights() {
          for (var i = 0; i < numOfLayers-1; i++) {
            var w
            if (i==0) {
              // w = math.zeros(X.size()[1],lengthOfHiddenLayer)
              w = math.matrix([ [1,2],  [3,4], [5,6] ])
            } else if (i == numOfLayers-2) {
              // w = math.zeros(lengthOfHiddenLayer,Y.size()[1])
              w = math.matrix([ [7],  [8] ])
            } else {
              w = math.zeros(lengthOfHiddenLayer,lengthOfHiddenLayer)
            }
            W.push(w)
          }
        }

        function sleep (time) {
          return new Promise((resolve) => setTimeout(resolve, time));
        }
        function addNeuron(x, y, r) {
          var circle = new createjs.Shape();
          circle.graphics.beginFill("DeepSkyBlue").drawCircle(0, 0, r);
          circle.x = x;
          circle.y = y;
          stage.addChild(circle);
          stage.update();
          return circle;
        }
        function connectNeurons(a, b) {
          var line = new createjs.Shape();
          line.graphics.beginStroke("DeepSkyBlue").moveTo(a.x, a.y).lineTo(b.x, b.y);
          stage.addChild(line);
          stage.update();
          return line;
        }
        function getLocation(loc, xDis, yDis) {
          return {
            x: loc.x+xDis,
            y: loc.y+yDis
          }
        }
        function labelConnection(a, b, input, weight) {
          var inputText = new createjs.Text(input, "30px Arial", "#ff7700");
          var weightText = new createjs.Text(weight, "30px Arial", "#7700ff");
          inputText.x = weightText.x = a.x;
          inputText.y = weightText.y = a.y;
          // angle in degrees
          // var angleDeg = Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI;
          // inputText.rotation = weightText.rotation = angleDeg;
          inputText.textBaseline = "bottom";
          weightText.textBaseline = "top";
          inputText.textAlign = weightText.textAlign = "center";
          stage.addChild(inputText);
          stage.addChild(weightText);
          stage.update();
          return {inputText: inputText, weightText: weightText};
        }
        function simulateLabels(input, weight, from, to, shouldClear) {
          createjs.Tween.get(input, {loop: false})
          .to({x: to.x, y: to.y}, duration, createjs.Ease.getPowInOut(4))
          .call(function(argument) {
            if (shouldClear) {
              stage.removeChild(input)
            }
          })
          createjs.Tween.get(weight, {loop: false})
          .to({x: to.x, y: to.y}, duration, createjs.Ease.getPowInOut(4))
          .call(function(argument) {
            if (shouldClear) {
              stage.removeChild(weight)
            }
          })
          
          createjs.Ticker.setFPS(60);
          createjs.Ticker.addEventListener("tick", stage)          
        }
        function pause(button) {
          createjs.Ticker.removeEventListener("tick", stage)
        }
      </script>
    </head>
    <body onload="init();">
      <canvas id="demoCanvas"></canvas>
      <button onclick="pause(this)">Pause</button>
    </body>
    </html>